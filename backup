<!DOCTYPE html>
<html>
    <head>
        
        <style>
        #canvas {
  left: 0;
  position: absolute;
  top: 0;
  z-index: -5;
            
}
        
        </style>
    </head>
    <body>
    
    
  <canvas id="canvas">
        
        
 </canvas>
        
        <div id="teste"></div>
    
    
    
     <script src="three.js"></script>
        <script>

   
    

init();
            
function criarcidade(){
    
    var geometry = new THREE.BoxGeometry(1200,10,1000);
    var material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
    
   
    
    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5));
    
    var cidade = new THREE.Mesh(geometry, material);
    
    cidade.position.set(0,0,0);
    cidade.scale.set(1,1,1);
    
    
    return cidade;
   
    
    
    
}

function shadeColor2(color, percent) {   
    var f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
    return "0x"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
}
            
            
function criarpredio(scene,x,z,altura){
    
    
    geometry = new THREE.BoxGeometry( 100, altura, 80 );
    
    //geometry.rotateY(30);
    
	/*material = new THREE.MeshBasicMaterial( { color: 0x2f9dbd, flatShading: THREE.FlatShading} );
    material.defaultColor =   0x2f9dbd;
    material.originalColor =  0x2f9dbd;
    */
    
    cor = '2f9dbd';
    
    
    geometry.faces[ 0 ].color.setHex( shadeColor2(cor,-0.2) );
    geometry.faces[ 1 ].color.setHex( shadeColor2(cor,-0.2) );
    geometry.faces[ 2 ].color.setHex( shadeColor2(cor,-0.2) );
    geometry.faces[ 3 ].color.setHex( shadeColor2(cor,-0.2) );
    geometry.faces[ 4 ].color.setHex( shadeColor2(cor,-0.2) );
    geometry.faces[ 5 ].color.setHex( shadeColor2(cor,-0.2) );
    geometry.faces[ 6 ].color.setHex( shadeColor2(cor,-0.2) );
    geometry.faces[ 7 ].color.setHex( shadeColor2(cor,-0.2) );
    geometry.faces[ 8 ].color.setHex( shadeColor2(cor,-0.1) );
    geometry.faces[ 9 ].color.setHex( shadeColor2(cor,-0.1) );
    geometry.faces[ 10 ].color.setHex( shadeColor2(cor,-0.1) );
    geometry.faces[ 11 ].color.setHex( shadeColor2(cor,-0.1) );
    
    
    //Math.random() * 0xffffff
    /*console.log(geometry.faces.length);
    for ( var i = 0; i < geometry.faces.length; i = i + 2 ) {
        
        console.log(c);
        geometry.faces[ i ].color.setHex( c );
        geometry.faces[ i+1 ].color.setHex( c );
                
    }*/

    var material = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
    
    /*
    
    for ( var i = 0; i < geometry.vertices.length; i++ ) 
    {
        point = geometry.vertices[ i ];
        color = new THREE.Color( 0xffffff );
        color.setRGB( 0.5 + point.x / 4, 0.5 + point.y / 4, 0.5 + point.z / 4 );
        geometry.colors[i] = color; // use this array for convenience
    }
    */
    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5));


    
    
    

	let teste = new THREE.Mesh( geometry, material );
   // teste.position.set(x,altura - altura / 2 ,z);
    teste.position.x = x;
    teste.position.y = altura - altura / 2;
    teste.scale.set(1,1,1);
    
    return teste;
    //scene.add(mesh);
    
    
}            
            
function colorLuminance(hex, lum) {
  let hex_string = ('000000' + hex.toString(16)).slice(-6);
  let rgb = "#";

  lum = lum || 0;

  for (let i = 0; i < 3; i++) {
    let num_color = parseInt(hex_string.substr(i * 2, 2), 16);
    let str_color = Math.round(Math.min(Math.max(0, num_color + (num_color * lum)), 255)).toString(16);

    rgb += ("00" + str_color).substr(str_color.length);
  }

  return rgb;
}            

function init() {
    
     var scene, camera, renderer;

	scene = new THREE.Scene();

    let width = window.innerWidth;
    let height = window.innerHeight;
    
    renderer = new THREE.WebGLRenderer({ antialias: true});
    renderer.setClearColor(0xcccccc, 1);
    renderer.setSize(width, height);
    document.getElementById("teste").appendChild(renderer.domElement);
    
    
    camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 10000000);
    camera.position.set(0,180,2000);
    scene.add(camera);
    
    
    
    
    var predio = new Array(); 
    
    var cidade = criarcidade(scene);  
    
    scene.add(cidade);
    
    
    predio1 = criarpredio(scene,-350,800,150);
    predio2 = criarpredio(scene,400,0,500);
    
    
    console.log(cidade);
    
    
    cidade.add(predio1,predio2);
   
    
    console.log(cidade.children);
    
    
    renderer.render( scene, camera );
    
    
    
    
    
    
    /*
            luz = new THREE.AmbientLight(0x777777);
    light = new THREE.PointLight(0xFFFFFF, 1, 0);
	light2 = new THREE.PointLight(0xFFFFFF, 1, 160);
	light3 = new THREE.PointLight(0xFFFF99, .3, 75);
	light4 = new THREE.PointLight(0xFFFF99, .3, 75);
    
            light.position.set(-5, 150, -5);
			light2.position.set(5, 150, 5);
			light3.position.set(5, 75, 5);
			light4.position.set(5, 75, 5);
			scene.add(luz);
			scene.add(light);
			scene.add(light2);
			scene.add(light3);
			scene.add(light4);
            
            */
    
    
    //renderer.domElement.addEventListener('mousemove', SceneManager.onDocumentMouseMove, false);
   // document.body.appendChild(renderer.domElement);
 
    
    
    /*var geometry2 = new THREE.PlaneBufferGeometry( 1300, 1600 );
	geometry2.rotateX( - Math.PI / 2 );
	var material2 = new THREE.MeshBasicMaterial( { color: 0xe0e0e0, overdraw: 0.5} );
	plane = new THREE.Mesh( geometry2, material2 );
    scene.add( plane );*/
    
    
    
    

	/*
    
    
    


	

    
    
    	// Plane
	
	
    
    */
    

    
    /*scene.add( mesh );
    scene.add(new THREE.AmbientLight(0xcccccc));
    
	
    
    */
    /*
    window.addEventListener('resize', () => {
      let width = window.innerWidth;
      let height = window.innerHeight;
    alert("REDIMENSIONOU");
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
        
        
    });*/

}


        
        </script>

        
        
       
               
    
    </body>
</html>